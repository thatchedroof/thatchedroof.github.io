"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var genericMeasureClass_1 = require("./genericMeasureClass");
var genericMeasureStatic_1 = require("./genericMeasureStatic");
var unitValueArithmetic_1 = require("./unitValueArithmetic");
/**
 * Creates a new measure factory for a given numeric type. The numeric type of the measure is inferred from the
 * parameter.
 * @param num the set of numeric operations needed to implement a measure for an arbitrary numeric type
 * @param staticMethods an object containing methods that should be spread into the static definition of a measure,
 * useful for attaching static math operations to the type.
 * @returns a factory for constructing measures of the given numeric type
 * @example
 * type MyMeasure<U extends Unit> = GenericMeasure<MyNumberType, U>;
 * const MyMeasure = createMeasureType({ ... });
 */
function createMeasureType(num, staticMethods) {
    var Measure = genericMeasureClass_1.createMeasureClass(num);
    var common = __assign({}, genericMeasureStatic_1.getGenericMeasureStaticMethods(), { isMeasure: function (value) { return value instanceof Measure; }, dimensionless: function (value) { return new Measure(value, {}); }, dimension: function (dim, symbol) {
            return new Measure(num.one(), unitValueArithmetic_1.dimension(dim, symbol), symbol);
        }, of: function (value, quantity, symbol) {
            return new Measure(num.mult(value, quantity.value), quantity.unit, symbol);
        } });
    return __assign({}, (staticMethods || {}), common);
}
exports.createMeasureType = createMeasureType;
//# sourceMappingURL=genericMeasureFactory.js.map