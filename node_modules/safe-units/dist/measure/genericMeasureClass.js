"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var exponentValueArithmetic_1 = require("../exponent/exponentValueArithmetic");
var format_1 = require("./format");
var unitValueArithmetic_1 = require("./unitValueArithmetic");
function createMeasureClass(num) {
    function getFormatter(formatter) {
        if (formatter === undefined) {
            return {
                formatValue: num.format,
                formatUnit: format_1.defaultFormatUnit,
            };
        }
        else {
            return {
                formatValue: formatter.formatValue || num.format,
                formatUnit: formatter.formatUnit || format_1.defaultFormatUnit,
            };
        }
    }
    var Measure = /** @class */ (function () {
        function Measure(value, unit, symbol) {
            this.value = value;
            this.unit = unit;
            this.symbol = symbol;
        }
        // Arithmetic
        Measure.prototype.plus = function (other) {
            return new Measure(num.add(this.value, other.value), this.unit);
        };
        Measure.prototype.minus = function (other) {
            return new Measure(num.sub(this.value, other.value), this.unit);
        };
        Measure.prototype.negate = function () {
            return new Measure(num.neg(this.value), this.unit);
        };
        Measure.prototype.scale = function (value) {
            return new Measure(num.mult(this.value, value), this.unit);
        };
        Measure.prototype.times = function (other) {
            // HACKHACK Need to cast as any to get around excessively deep type instantiation error
            return new Measure(num.mult(this.value, other.value), unitValueArithmetic_1.multiplyUnits(this.unit, other.unit));
        };
        Measure.prototype.over = function (other) {
            // HACKHACK Need to cast as any to get around excessively deep type instantiation error
            return new Measure(num.div(this.value, other.value), unitValueArithmetic_1.divideUnits(this.unit, other.unit));
        };
        Measure.prototype.per = function (other) {
            return this.over(other);
        };
        Measure.prototype.div = function (other) {
            return this.over(other);
        };
        Measure.prototype.toThe = function (power) {
            return new Measure(num.pow(this.value, exponentValueArithmetic_1.getExponentValue(power)), unitValueArithmetic_1.exponentiateUnit(this.unit, power));
        };
        Measure.prototype.inverse = function () {
            return this.toThe("-1");
        };
        Measure.prototype.reciprocal = function () {
            return this.toThe("-1");
        };
        Measure.prototype.unsafeMap = function (valueMap, unitMap) {
            var newUnit = unitMap === undefined ? this.unit : unitMap(this.unit);
            return new Measure(valueMap(this.value), newUnit);
        };
        // Comparisons
        Measure.prototype.compare = function (other) {
            return num.compare(this.value, other.value);
        };
        Measure.prototype.lt = function (other) {
            return this.compare(other) < 0;
        };
        Measure.prototype.lte = function (other) {
            return this.compare(other) <= 0;
        };
        Measure.prototype.eq = function (other) {
            return this.compare(other) === 0;
        };
        Measure.prototype.neq = function (other) {
            return this.compare(other) !== 0;
        };
        Measure.prototype.gte = function (other) {
            return this.compare(other) >= 0;
        };
        Measure.prototype.gt = function (other) {
            return this.compare(other) > 0;
        };
        // Formatting
        Measure.prototype.toString = function (formatter) {
            var _a = getFormatter(formatter), formatValue = _a.formatValue, formatUnit = _a.formatUnit;
            return (formatValue(this.value) + " " + formatUnit(this.unit)).trimRight();
        };
        Measure.prototype.in = function (unit, formatter) {
            if (unit.symbol === undefined) {
                return this.toString(formatter);
            }
            var formatValue = getFormatter(formatter).formatValue;
            var value = formatValue(num.div(this.value, unit.value));
            return value + " " + unit.symbol;
        };
        Measure.prototype.withSymbol = function (symbol) {
            return new Measure(this.value, this.unit, symbol);
        };
        Measure.prototype.clone = function () {
            return new Measure(this.value, this.unit);
        };
        return Measure;
    }());
    Measure.prototype.squared = function () {
        return this.toThe("2");
    };
    Measure.prototype.cubed = function () {
        return this.toThe("3");
    };
    return Measure;
}
exports.createMeasureClass = createMeasureClass;
//# sourceMappingURL=genericMeasureClass.js.map