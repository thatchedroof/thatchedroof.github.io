"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var unitValueArithmetic_1 = require("./unitValueArithmetic");
/**
 * Converts a unary function of unitless numbers into a function of measures. This assumes that the underlying
 * operation makes no change to the unit of the measure. For example, this would be an incorrect usage:
 * `square = wrapUnaryFn((value: number) => value ** 2)` since squaring a measure would change its unit.
 * @param fn a unary function of numeric types
 * @returns a unary function of measures
 */
function wrapUnaryFn(fn) {
    return function (x) { return x.unsafeMap(fn); };
}
exports.wrapUnaryFn = wrapUnaryFn;
/**
 * Converts a function that takes the nth root of a number type (for a specific n) into a function of measures. The `n`
 * parameter must be a constant which matches the root that the function takes (e.g. 2 for square root, 3 for cube
 * root).
 * @param nthRoot a function that takes a specific root of a numeric type
 * @param n a compile time constant specifying which nth root the first parameter performs
 * @returns a function of measures which takes the nth root of the value and the unit.
 */
function wrapRootFn(nthRoot, n) {
    return function (x) { return x.unsafeMap(nthRoot, function (unit) { return unitValueArithmetic_1.nthRootUnit(unit, n); }); };
}
exports.wrapRootFn = wrapRootFn;
/**
 * Converts a binary function of unitless numbers into a function of measures. This assumes that the underlying
 * operation makes no change to the unit of the measure. For example, this would be an incorrect usage:
 * `mult = wrapBinaryFn((left, right) => left * right)` since multiplying two measures would result in a different unit.
 * @param fn a binary function of numeric types
 * @returns a binary function of measures
 */
function wrapBinaryFn(fn) {
    return function (left, right) { return left.unsafeMap(function (lValue) { return fn(lValue, right.value); }); };
}
exports.wrapBinaryFn = wrapBinaryFn;
/**
 * Converts a function of any number of unitless numbers into a function of one or more measures. This assumes that the
 * underlying operation makes no change to the unit of the measure. For example, this would be an incorrect usage:
 * `product = wrapBinaryFn((...values) => product(values))` since multiplying measures would result in a different unit.
 * Note that the resulting function requires at least one value in order to compute the unit of the resulting measure.
 * @param fn a spread function of numeric types
 * @returns a spread function of measures
 */
function wrapSpreadFn(fn) {
    return function (first) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var measureValues = [first].concat(rest).map(function (m) { return m.value; });
        var newValue = fn.apply(void 0, measureValues);
        return first.unsafeMap(function () { return newValue; });
    };
}
exports.wrapSpreadFn = wrapSpreadFn;
/**
 * Converts a binary function of unitless numbers into a function of one or more measures by using that function as a
 * reducer for the measures. This assumes that the underlying operation makes no change to the unit of the measure. For
 * example this would be an incorrect usage: `product = wrapReducerFn((prev, curr) => prev * curr)` since multiplying
 * two measures would result in a different unit. Note that the resulting function requires at least one value in order
 * to compute the unit of the resulting measure.
 * @param fn a binary function of numeric types
 * @returns a spread function of measures that reduces its arguments using the binary function passed
 */
function wrapReducerFn(fn) {
    return function (first) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var values = rest.map(function (m) { return m.value; });
        return first.unsafeMap(function () { return values.reduce(fn, first.value); });
    };
}
exports.wrapReducerFn = wrapReducerFn;
//# sourceMappingURL=genericMeasureUtils.js.map