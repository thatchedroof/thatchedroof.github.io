"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var exponentValueArithmetic_1 = require("../exponent/exponentValueArithmetic");
function dimension(dim, symbol) {
    var _a;
    return _a = {}, _a[dim] = [symbol || dim, "1"], _a;
}
exports.dimension = dimension;
function multiplyUnits(left, right) {
    var result = {};
    for (var dimension_1 in left) {
        var symbolAndExponent = copySymbolAndExponent(left, dimension_1);
        if (symbolAndExponent !== undefined && symbolAndExponent[1] !== "0") {
            result[dimension_1] = symbolAndExponent;
        }
    }
    for (var dimension_2 in right) {
        var symbolAndExponent = copySymbolAndExponent(right, dimension_2);
        if (symbolAndExponent === undefined) {
            continue;
        }
        var exponent = symbolAndExponent[1];
        var resultValue = result[dimension_2];
        if (resultValue !== undefined) {
            var newExponent = exponentValueArithmetic_1.addExponents(resultValue[1], exponent);
            if (newExponent === "0") {
                delete result[dimension_2];
            }
            else {
                resultValue[1] = newExponent;
            }
        }
        else if (exponent !== "0") {
            result[dimension_2] = symbolAndExponent;
        }
    }
    return result;
}
exports.multiplyUnits = multiplyUnits;
function copySymbolAndExponent(unit, dimension) {
    var result = unit[dimension];
    if (result === undefined) {
        return undefined;
    }
    var symbol = result[0], exponent = result[1];
    return [symbol, exponent];
}
function divideUnits(left, right) {
    var rightInverse = exponentiateUnit(right, "-1");
    return multiplyUnits(left, rightInverse);
}
exports.divideUnits = divideUnits;
function exponentiateUnit(unit, power) {
    return expAndRootImpl(unit, function (exponent) { return exponentValueArithmetic_1.multiplyExponents(exponent, power); });
}
exports.exponentiateUnit = exponentiateUnit;
function nthRootUnit(unit, root) {
    return expAndRootImpl(unit, function (exponent) { return exponentValueArithmetic_1.divideExponents(exponent, root); });
}
exports.nthRootUnit = nthRootUnit;
function expAndRootImpl(unit, updateExponent) {
    var result = {};
    for (var dimension_3 in unit) {
        var symbolAndExponent = unit[dimension_3];
        if (symbolAndExponent === undefined) {
            continue;
        }
        var symbol = symbolAndExponent[0], exponent = symbolAndExponent[1];
        var newExponent = updateExponent(exponent);
        if (newExponent !== "0") {
            result[dimension_3] = [symbol, newExponent];
        }
    }
    return result;
}
//# sourceMappingURL=unitValueArithmetic.js.map